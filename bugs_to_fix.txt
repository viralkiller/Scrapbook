Here are the two most likely culprits that cause it to “work fine at first” but fail on subsequent executions—even though the chain looks valid on‑screen:

1) The Front-End Topological Sort Always Expects All Nodes to Be in One DAG
In execute-button.js, the function:

js
Copy
function topoSort(adjacency) {
  // ...
  if (result.length !== Object.keys(adjacency).length) {
    console.error("Cycle detected in node graph.");
    return null;
  }
  return result;
}
Problem: If any node in adjacency is disconnected or forms a small subgraph, result.length will be smaller than Object.keys(adjacency).length. The code concludes there is a “cycle” and returns null. Once it returns null, your chain is declared invalid ("You need to create a line chain from input to output!")—even if the main subgraph from input_text to output_text was perfectly fine.

Why This Breaks on Subsequent Tries
On the very first load, you may have fewer nodes, or no stray lines. The topological sort passes.
Later, you add or hide an extra node that’s not fully connected from input to output. Because the code tries to topological-sort all nodes in adjacency, it hits that mismatch in length (result.length !== Object.keys(adjacency).length) and bails out as if there is a cycle.
Once that happens, every subsequent run also sees the leftover “extra” node or subgraph, and keeps failing.
Fix: Only topological-sort the subgraph that’s actually reachable
Either remove that if (...) { return null; } check or do a “partial” topological sort only on the nodes that are forward/backward reachable. In other words, ignore stray or disconnected nodes. For example:

js
Copy
// Instead of sorting the entire adjacency, sort only the valid subset:
function partialTopoSort(adjacency, validNodes) {
  // validNodes is what your BFS from input->output returned
  const inDegree = {};
  // Only track in-degree for validNodes
  validNodes.forEach(node => { inDegree[node] = 0; });

  // Build in-degrees only for edges within the valid subset
  validNodes.forEach(node => {
    if (!adjacency[node]) return;
    adjacency[node].forEach(child => {
      if (validNodes.has(child)) {
        inDegree[child] = (inDegree[child] || 0) + 1;
      }
    });
  });

  // standard BFS-based topological sort
  const queue = Object.keys(inDegree).filter(node => inDegree[node] === 0);
  const result = [];

  while (queue.length) {
    const current = queue.shift();
    result.push(current);
    (adjacency[current] || []).forEach(child => {
      if (validNodes.has(child)) {
        inDegree[child]--;
        if (inDegree[child] === 0) queue.push(child);
      }
    });
  }
  // We don't require result.length === validNodes.size
  // We only return "null" if there's an actual cycle within that sub-subgraph
  return (result.length === validNodes.size) ? result : null;
}
Then your front-end won’t blow up just because you have an extra node that isn’t part of the main chain.

2) Double‑Click Handling (or Hiding a Node) Removes Connections
Your code calls:

js
Copy
function onConnectionPortDoubleClick(e) {
  // ...
  // removes any lines on that port
  connections = connections.filter(...);
}
Also in tool-palette.js, hiding a node calls:

js
Copy
NodePalette.toggleNodeVisibility(nodeId, false) {
  // ...
  clearAllConnectionsNode(nodeId);
}
If you happen to double-click a port (or hide a node from the toolbar, etc.), all lines on that port get removed. If that node was key to the chain, BFS won’t find a path and you’ll get the “no chain” error.

In many browsers, a quick second click or trackpad tap can accidentally register as a “double click.” That breaks the chain for subsequent calls.

Fix:
Decide if you really want to remove all lines on double-click, or if that was a debug feature.
Possibly require Shift+click or a trash icon.
Summary of the Main Bugs
Topological sort code in execute-button.js returns null if the number of sorted nodes is less than the total adjacency count.

This kills the entire chain if you have any extra or half-connected node.
Double-click or “hide node” forcibly removes connections.

If that node was your path from input → output, BFS will fail on subsequent tries.
Once you fix these two, you should see your merges remain stable, and the chain recognition continue to work on subsequent executions.
